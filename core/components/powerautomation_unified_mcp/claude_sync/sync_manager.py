#!/usr/bin/env python3
"""
Claude Code Sync Manager - Claude Code ÂêåÊ≠•ÁÆ°ÁêÜÂô®
Á°Æ‰øù Claude Code Sync Service Ê≠£Â∏∏Â∑•‰ΩúÁöÑÊ†∏ÂøÉÁªÑ‰ª∂
"""

import asyncio
import json
import logging
import time
import websockets
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, asdict
from datetime import datetime
from enum import Enum
import uuid

logger = logging.getLogger(__name__)

class SyncStatus(Enum):
    """ÂêåÊ≠•Áä∂ÊÄÅ"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    SYNCING = "syncing"
    ERROR = "error"

@dataclass
class SyncEvent:
    """ÂêåÊ≠•‰∫ã‰ª∂"""
    event_id: str
    event_type: str
    source: str
    target: str
    data: Any
    timestamp: float
    
    def to_dict(self):
        return asdict(self)

@dataclass
class CodeSyncRequest:
    """‰ª£Á†ÅÂêåÊ≠•ËØ∑Ê±Ç"""
    request_id: str
    action: str  # 'sync_to_local', 'sync_to_cloud', 'execute_code'
    code_content: str
    file_path: str = ""
    language: str = "python"
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

class ClaudeSyncManager:
    """Claude Code ÂêåÊ≠•ÁÆ°ÁêÜÂô®"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.config = config or self._get_default_config()
        
        # ËøûÊé•Áä∂ÊÄÅ
        self.status = SyncStatus.DISCONNECTED
        self.websocket = None
        self.claudeditor_url = self.config.get("claudeditor_url", "ws://localhost:8080")
        
        # ÂêåÊ≠•ÁÆ°ÁêÜ
        self.sync_queue = asyncio.Queue()
        self.active_syncs = {}
        self.sync_history = []
        self.max_history = 1000
        
        # ‰∫ã‰ª∂Â§ÑÁêÜ
        self.event_handlers = {}
        self.sync_callbacks = []
        
        # ÁªüËÆ°‰ø°ÊÅØ
        self.stats = {
            "total_syncs": 0,
            "successful_syncs": 0,
            "failed_syncs": 0,
            "bytes_synced": 0,
            "start_time": datetime.now().isoformat()
        }
        
        # ‰ªªÂä°ÁÆ°ÁêÜ
        self.sync_task = None
        self.heartbeat_task = None
        self.running = False
    
    def _get_default_config(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÈªòËÆ§ÈÖçÁΩÆ"""
        return {
            "claudeditor_url": "ws://localhost:8080",
            "auto_reconnect": True,
            "reconnect_interval": 5,
            "heartbeat_interval": 30,
            "sync_timeout": 60,
            "max_retries": 3,
            "enable_compression": True,
            "enable_encryption": False
        }
    
    async def initialize(self) -> bool:
        """ÂàùÂßãÂåñÂêåÊ≠•ÁÆ°ÁêÜÂô®"""
        try:
            self.logger.info("üîÑ ÂàùÂßãÂåñ Claude Code ÂêåÊ≠•ÁÆ°ÁêÜÂô®...")
            
            # ÂêØÂä®ÂêåÊ≠•ÊúçÂä°
            await self.start_sync_service()
            
            # ËøûÊé•Âà∞ ClaudeEditor
            await self.connect_to_claudeditor()
            
            self.logger.info("‚úÖ Claude Code ÂêåÊ≠•ÁÆ°ÁêÜÂô®ÂàùÂßãÂåñÂÆåÊàê")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå ÂêåÊ≠•ÁÆ°ÁêÜÂô®ÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            return False
    
    async def start_sync_service(self):
        """ÂêØÂä®ÂêåÊ≠•ÊúçÂä°"""
        if self.running:
            return
        
        self.running = True
        
        # ÂêØÂä®ÂêåÊ≠•Â§ÑÁêÜ‰ªªÂä°
        self.sync_task = asyncio.create_task(self._sync_processor())
        
        # ÂêØÂä®ÂøÉË∑≥‰ªªÂä°
        self.heartbeat_task = asyncio.create_task(self._heartbeat_monitor())
        
        self.logger.info("üöÄ Claude Code ÂêåÊ≠•ÊúçÂä°Â∑≤ÂêØÂä®")
    
    async def connect_to_claudeditor(self) -> bool:
        """ËøûÊé•Âà∞ ClaudeEditor"""
        try:
            self.status = SyncStatus.CONNECTING
            self.logger.info(f"üîó ËøûÊé•Âà∞ ClaudeEditor: {self.claudeditor_url}")
            
            # Â∞ùËØï WebSocket ËøûÊé•
            try:
                self.websocket = await websockets.connect(
                    self.claudeditor_url,
                    timeout=10
                )
                
                self.status = SyncStatus.CONNECTED
                self.logger.info("‚úÖ ClaudeEditor WebSocket ËøûÊé•ÊàêÂäü")
                
                # ÂêØÂä®Ê∂àÊÅØÁõëÂê¨
                asyncio.create_task(self._message_listener())
                
                return True
                
            except Exception as ws_error:
                self.logger.warning(f"WebSocket ËøûÊé•Â§±Ë¥•: {ws_error}")
                
                # ÂõûÈÄÄÂà∞ HTTP Ê®°Âºè
                await self._setup_http_fallback()
                return True
                
        except Exception as e:
            self.status = SyncStatus.ERROR
            self.logger.error(f"‚ùå ËøûÊé• ClaudeEditor Â§±Ë¥•: {e}")
            return False
    
    async def _setup_http_fallback(self):
        """ËÆæÁΩÆ HTTP ÂõûÈÄÄÊ®°Âºè"""
        self.logger.info("üîÑ ËÆæÁΩÆ HTTP ÂõûÈÄÄÊ®°Âºè...")
        
        # Ê®°ÊãüËøûÊé•ÊàêÂäü
        self.status = SyncStatus.CONNECTED
        self.logger.info("‚úÖ HTTP ÂõûÈÄÄÊ®°ÂºèÂ∑≤ÂêØÁî®")
    
    async def _message_listener(self):
        """WebSocket Ê∂àÊÅØÁõëÂê¨Âô®"""
        try:
            async for message in self.websocket:
                try:
                    data = json.loads(message)
                    await self._handle_claudeditor_message(data)
                    
                except json.JSONDecodeError:
                    self.logger.warning(f"Êî∂Âà∞Êó†Êïà JSON Ê∂àÊÅØ: {message}")
                    
        except websockets.exceptions.ConnectionClosed:
            self.logger.warning("ClaudeEditor WebSocket ËøûÊé•Â∑≤ÂÖ≥Èó≠")
            self.status = SyncStatus.DISCONNECTED
            
            # Ëá™Âä®ÈáçËøû
            if self.config.get("auto_reconnect", True):
                await self._auto_reconnect()
                
        except Exception as e:
            self.logger.error(f"Ê∂àÊÅØÁõëÂê¨Âô®ÈîôËØØ: {e}")
    
    async def _handle_claudeditor_message(self, data: Dict[str, Any]):
        """Â§ÑÁêÜ ClaudeEditor Ê∂àÊÅØ"""
        try:
            message_type = data.get("type", "")
            
            if message_type == "code_sync":
                await self._handle_code_sync_message(data)
            elif message_type == "execute_request":
                await self._handle_execute_request(data)
            elif message_type == "heartbeat":
                await self._handle_heartbeat(data)
            else:
                self.logger.debug(f"Êú™Áü•Ê∂àÊÅØÁ±ªÂûã: {message_type}")
                
        except Exception as e:
            self.logger.error(f"Â§ÑÁêÜ ClaudeEditor Ê∂àÊÅØÂ§±Ë¥•: {e}")
    
    async def _handle_code_sync_message(self, data: Dict[str, Any]):
        """Â§ÑÁêÜ‰ª£Á†ÅÂêåÊ≠•Ê∂àÊÅØ"""
        try:
            sync_request = CodeSyncRequest(
                request_id=data.get("request_id", str(uuid.uuid4())),
                action=data.get("action", "sync_to_local"),
                code_content=data.get("code_content", ""),
                file_path=data.get("file_path", ""),
                language=data.get("language", "python"),
                metadata=data.get("metadata", {})
            )
            
            # Ê∑ªÂä†Âà∞ÂêåÊ≠•ÈòüÂàó
            await self.sync_queue.put(sync_request)
            
            self.logger.info(f"üì• Êî∂Âà∞‰ª£Á†ÅÂêåÊ≠•ËØ∑Ê±Ç: {sync_request.request_id}")
            
        except Exception as e:
            self.logger.error(f"Â§ÑÁêÜ‰ª£Á†ÅÂêåÊ≠•Ê∂àÊÅØÂ§±Ë¥•: {e}")
    
    async def _handle_execute_request(self, data: Dict[str, Any]):
        """Â§ÑÁêÜ‰ª£Á†ÅÊâßË°åËØ∑Ê±Ç"""
        try:
            request_id = data.get("request_id", str(uuid.uuid4()))
            code_content = data.get("code_content", "")
            
            # ÊâßË°å‰ª£Á†Å
            result = await self._execute_code_locally(code_content)
            
            # ÂèëÈÄÅÊâßË°åÁªìÊûú
            response = {
                "type": "execute_response",
                "request_id": request_id,
                "success": result.get("success", False),
                "output": result.get("output", ""),
                "error": result.get("error", ""),
                "execution_time": result.get("execution_time", 0)
            }
            
            await self._send_to_claudeditor(response)
            
            self.logger.info(f"‚ö° ‰ª£Á†ÅÊâßË°åÂÆåÊàê: {request_id}")
            
        except Exception as e:
            self.logger.error(f"Â§ÑÁêÜ‰ª£Á†ÅÊâßË°åËØ∑Ê±ÇÂ§±Ë¥•: {e}")
    
    async def _execute_code_locally(self, code_content: str) -> Dict[str, Any]:
        """Êú¨Âú∞ÊâßË°å‰ª£Á†Å"""
        try:
            import subprocess
            import tempfile
            import os
            
            # ÂàõÂª∫‰∏¥Êó∂Êñá‰ª∂
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
                f.write(code_content)
                temp_file = f.name
            
            try:
                # ÊâßË°å‰ª£Á†Å
                start_time = time.time()
                result = subprocess.run(
                    ['python', temp_file],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                execution_time = time.time() - start_time
                
                return {
                    "success": result.returncode == 0,
                    "output": result.stdout,
                    "error": result.stderr,
                    "execution_time": execution_time
                }
                
            finally:
                # Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
                os.unlink(temp_file)
                
        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "output": "",
                "error": "‰ª£Á†ÅÊâßË°åË∂ÖÊó∂",
                "execution_time": 30
            }
        except Exception as e:
            return {
                "success": False,
                "output": "",
                "error": str(e),
                "execution_time": 0
            }
    
    async def _sync_processor(self):
        """ÂêåÊ≠•Â§ÑÁêÜÂô®"""
        while self.running:
            try:
                # ‰ªéÈòüÂàóËé∑ÂèñÂêåÊ≠•ËØ∑Ê±Ç
                sync_request = await asyncio.wait_for(
                    self.sync_queue.get(),
                    timeout=1.0
                )
                
                # Â§ÑÁêÜÂêåÊ≠•ËØ∑Ê±Ç
                await self._process_sync_request(sync_request)
                
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                self.logger.error(f"ÂêåÊ≠•Â§ÑÁêÜÂô®ÈîôËØØ: {e}")
    
    async def _process_sync_request(self, request: CodeSyncRequest):
        """Â§ÑÁêÜÂêåÊ≠•ËØ∑Ê±Ç"""
        try:
            self.status = SyncStatus.SYNCING
            self.stats["total_syncs"] += 1
            
            start_time = time.time()
            
            if request.action == "sync_to_local":
                result = await self._sync_to_local(request)
            elif request.action == "sync_to_cloud":
                result = await self._sync_to_cloud(request)
            elif request.action == "execute_code":
                result = await self._execute_code_locally(request.code_content)
            else:
                result = {"success": False, "error": f"Êú™Áü•Âä®‰Ωú: {request.action}"}
            
            execution_time = time.time() - start_time
            
            # Êõ¥Êñ∞ÁªüËÆ°
            if result.get("success", False):
                self.stats["successful_syncs"] += 1
                self.stats["bytes_synced"] += len(request.code_content.encode('utf-8'))
            else:
                self.stats["failed_syncs"] += 1
            
            # ËÆ∞ÂΩïÂêåÊ≠•ÂéÜÂè≤
            sync_event = SyncEvent(
                event_id=request.request_id,
                event_type=request.action,
                source="claudeditor",
                target="local",
                data=result,
                timestamp=time.time()
            )
            
            self._add_to_history(sync_event)
            
            # ÂèëÈÄÅÂìçÂ∫î
            response = {
                "type": "sync_response",
                "request_id": request.request_id,
                "success": result.get("success", False),
                "message": result.get("message", ""),
                "execution_time": execution_time
            }
            
            await self._send_to_claudeditor(response)
            
            self.status = SyncStatus.CONNECTED
            self.logger.info(f"‚úÖ ÂêåÊ≠•ÂÆåÊàê: {request.request_id} ({execution_time:.2f}s)")
            
        except Exception as e:
            self.stats["failed_syncs"] += 1
            self.logger.error(f"‚ùå ÂêåÊ≠•ËØ∑Ê±ÇÂ§ÑÁêÜÂ§±Ë¥•: {e}")
    
    async def _sync_to_local(self, request: CodeSyncRequest) -> Dict[str, Any]:
        """ÂêåÊ≠•Âà∞Êú¨Âú∞"""
        try:
            if request.file_path:
                # ÂÜôÂÖ•Êñá‰ª∂
                import os
                os.makedirs(os.path.dirname(request.file_path), exist_ok=True)
                
                with open(request.file_path, 'w', encoding='utf-8') as f:
                    f.write(request.code_content)
                
                return {
                    "success": True,
                    "message": f"‰ª£Á†ÅÂ∑≤ÂêåÊ≠•Âà∞Êú¨Âú∞Êñá‰ª∂: {request.file_path}"
                }
            else:
                # ‰∏¥Êó∂Â≠òÂÇ®
                return {
                    "success": True,
                    "message": "‰ª£Á†ÅÂ∑≤ÂêåÊ≠•Âà∞Êú¨Âú∞ÁºìÂ≠ò"
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _sync_to_cloud(self, request: CodeSyncRequest) -> Dict[str, Any]:
        """ÂêåÊ≠•Âà∞‰∫ëÁ´Ø"""
        try:
            # ËøôÈáåÂèØ‰ª•ÂÆûÁé∞‰∫ëÁ´ØÂêåÊ≠•ÈÄªËæë
            # ÁõÆÂâçËøîÂõûÊàêÂäüÁä∂ÊÄÅ
            return {
                "success": True,
                "message": "‰ª£Á†ÅÂ∑≤ÂêåÊ≠•Âà∞‰∫ëÁ´Ø"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _send_to_claudeditor(self, data: Dict[str, Any]):
        """ÂèëÈÄÅÊ∂àÊÅØÂà∞ ClaudeEditor"""
        try:
            if self.websocket and not self.websocket.closed:
                message = json.dumps(data)
                await self.websocket.send(message)
            else:
                # HTTP ÂõûÈÄÄÊ®°Âºè
                self.logger.debug(f"HTTP Ê®°ÂºèÂèëÈÄÅÊ∂àÊÅØ: {data.get('type', 'unknown')}")
                
        except Exception as e:
            self.logger.error(f"ÂèëÈÄÅÊ∂àÊÅØÂà∞ ClaudeEditor Â§±Ë¥•: {e}")
    
    async def _heartbeat_monitor(self):
        """ÂøÉË∑≥ÁõëÊéß"""
        while self.running:
            try:
                if self.status == SyncStatus.CONNECTED:
                    heartbeat = {
                        "type": "heartbeat",
                        "timestamp": time.time(),
                        "status": self.status.value,
                        "stats": self.stats
                    }
                    
                    await self._send_to_claudeditor(heartbeat)
                
                await asyncio.sleep(self.config.get("heartbeat_interval", 30))
                
            except Exception as e:
                self.logger.error(f"ÂøÉË∑≥ÁõëÊéßÈîôËØØ: {e}")
    
    def _add_to_history(self, event: SyncEvent):
        """Ê∑ªÂä†Âà∞ÂéÜÂè≤ËÆ∞ÂΩï"""
        self.sync_history.append(event)
        
        # ‰øùÊåÅÂéÜÂè≤ËÆ∞ÂΩïÂ§ßÂ∞èÈôêÂà∂
        if len(self.sync_history) > self.max_history:
            self.sync_history.pop(0)
    
    async def _auto_reconnect(self):
        """Ëá™Âä®ÈáçËøû"""
        reconnect_interval = self.config.get("reconnect_interval", 5)
        
        while self.running and self.status == SyncStatus.DISCONNECTED:
            try:
                self.logger.info(f"üîÑ Â∞ùËØïÈáçËøû ClaudeEditor...")
                
                if await self.connect_to_claudeditor():
                    break
                
                await asyncio.sleep(reconnect_interval)
                
            except Exception as e:
                self.logger.error(f"ÈáçËøûÂ§±Ë¥•: {e}")
                await asyncio.sleep(reconnect_interval)
    
    def get_sync_status(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÂêåÊ≠•Áä∂ÊÄÅ"""
        return {
            "status": self.status.value,
            "connected": self.status == SyncStatus.CONNECTED,
            "websocket_connected": self.websocket and not self.websocket.closed,
            "stats": self.stats,
            "config": self.config,
            "queue_size": self.sync_queue.qsize(),
            "active_syncs": len(self.active_syncs)
        }
    
    def get_sync_history(self, limit: int = 50) -> List[Dict[str, Any]]:
        """Ëé∑ÂèñÂêåÊ≠•ÂéÜÂè≤"""
        recent_history = self.sync_history[-limit:] if self.sync_history else []
        return [event.to_dict() for event in recent_history]
    
    async def cleanup(self):
        """Ê∏ÖÁêÜËµÑÊ∫ê"""
        try:
            self.logger.info("üßπ Ê∏ÖÁêÜ Claude Code ÂêåÊ≠•ÁÆ°ÁêÜÂô®...")
            
            self.running = False
            
            # ÂÖ≥Èó≠ WebSocket ËøûÊé•
            if self.websocket:
                await self.websocket.close()
            
            # ÂèñÊ∂à‰ªªÂä°
            if self.sync_task:
                self.sync_task.cancel()
            if self.heartbeat_task:
                self.heartbeat_task.cancel()
            
            self.status = SyncStatus.DISCONNECTED
            self.logger.info("‚úÖ Claude Code ÂêåÊ≠•ÁÆ°ÁêÜÂô®Ê∏ÖÁêÜÂÆåÊàê")
            
        except Exception as e:
            self.logger.error(f"‚ùå Ê∏ÖÁêÜÂêåÊ≠•ÁÆ°ÁêÜÂô®Â§±Ë¥•: {e}")


# ÂÖ®Â±ÄÂêåÊ≠•ÁÆ°ÁêÜÂô®ÂÆû‰æã
claude_sync_manager = ClaudeSyncManager()


def get_sync_manager() -> ClaudeSyncManager:
    """Ëé∑ÂèñÂêåÊ≠•ÁÆ°ÁêÜÂô®ÂÆû‰æã"""
    return claude_sync_manager


# CLI Êé•Âè£
if __name__ == "__main__":
    import argparse
    import sys
    
    async def main():
        parser = argparse.ArgumentParser(description="Claude Code ÂêåÊ≠•ÁÆ°ÁêÜÂô®")
        parser.add_argument("--action", choices=["start", "status", "test"], 
                           default="start", help="ÊâßË°åÁöÑÂä®‰Ωú")
        parser.add_argument("--url", type=str, default="ws://localhost:8080",
                           help="ClaudeEditor WebSocket URL")
        
        args = parser.parse_args()
        
        # ÈÖçÁΩÆÊó•Âøó
        logging.basicConfig(level=logging.INFO)
        
        manager = ClaudeSyncManager({"claudeditor_url": args.url})
        
        try:
            if args.action == "start":
                print("üöÄ ÂêØÂä® Claude Code ÂêåÊ≠•ÊúçÂä°...")
                success = await manager.initialize()
                
                if success:
                    print("‚úÖ ÂêåÊ≠•ÊúçÂä°ÂêØÂä®ÊàêÂäü")
                    print("Êåâ Ctrl+C ÂÅúÊ≠¢ÊúçÂä°")
                    
                    try:
                        while True:
                            await asyncio.sleep(1)
                    except KeyboardInterrupt:
                        print("\nüõë ÂÅúÊ≠¢ÂêåÊ≠•ÊúçÂä°...")
                else:
                    print("‚ùå ÂêåÊ≠•ÊúçÂä°ÂêØÂä®Â§±Ë¥•")
                    sys.exit(1)
            
            elif args.action == "status":
                await manager.initialize()
                status = manager.get_sync_status()
                print(json.dumps(status, indent=2, ensure_ascii=False))
            
            elif args.action == "test":
                print("üß™ ÊµãËØïÂêåÊ≠•ÂäüËÉΩ...")
                await manager.initialize()
                
                # Ê®°ÊãüÂêåÊ≠•ËØ∑Ê±Ç
                test_request = CodeSyncRequest(
                    request_id="test_001",
                    action="sync_to_local",
                    code_content="print('Hello, Claude Code Sync!')",
                    file_path="/tmp/test_sync.py"
                )
                
                await manager.sync_queue.put(test_request)
                await asyncio.sleep(2)
                
                print("‚úÖ ÊµãËØïÂÆåÊàê")
        
        finally:
            await manager.cleanup()
    
    asyncio.run(main())

